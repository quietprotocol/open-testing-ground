#!/bin/sh /etc/rc.common
# USB-C Gadget Mode Init Script
# This script loads the USB ethernet gadget module and adds usb0 to the mesh network bridge

START=95
STOP=10

# Define status_service function early so rc.common can detect it
status_service() {
	if lsmod | grep -q "^g_ether"; then
		echo "USB gadget module (g_ether) is loaded"
	else
		echo "USB gadget module (g_ether) is NOT loaded"
		return 1
	fi
	
	if ip link show {{ usbc_gadget_interface }} >/dev/null 2>&1; then
		echo "Interface {{ usbc_gadget_interface }} exists"
		if ip link show {{ usbc_gadget_interface }} | grep -q "state UP"; then
			echo "Interface {{ usbc_gadget_interface }} is UP"
		else
			echo "Interface {{ usbc_gadget_interface }} is DOWN"
		fi
		
		# Check if usb0 is in the bridge
		if brctl show {{ usbc_gadget_mesh_bridge }} 2>/dev/null | grep -q "{{ usbc_gadget_interface }}"; then
			echo "Interface {{ usbc_gadget_interface }} is in bridge {{ usbc_gadget_mesh_bridge }}"
		elif bridge link show 2>/dev/null | grep -q "{{ usbc_gadget_interface }}"; then
			echo "Interface {{ usbc_gadget_interface }} is in bridge {{ usbc_gadget_mesh_bridge }}"
		else
			echo "Interface {{ usbc_gadget_interface }} is NOT in bridge {{ usbc_gadget_mesh_bridge }}"
			return 1
		fi
	else
		echo "Interface {{ usbc_gadget_interface }} does NOT exist"
		return 1
	fi
}

start_service() {
	# Load g_ether module if not already loaded
	# Retry loading in case USB subsystem isn't ready yet
	# Try CDC-ECM first (better Linux/Android compatibility), fallback to default (RNDIS)
	if ! lsmod | grep -q "^g_ether"; then
		counter=0
		module_loaded=0
		while [ $counter -lt 5 ] && [ $module_loaded -eq 0 ]; do
			# Try loading with use_eem=0 to prefer CDC-ECM over RNDIS
			# This may work better with some Android devices
			if modprobe g_ether use_eem=0 2>&1; then
				# Verify module actually loaded
				if lsmod | grep -q "^g_ether"; then
					module_loaded=1
					break
				fi
			fi
			# Fallback to default (RNDIS) if CDC-ECM fails
			if modprobe g_ether 2>&1; then
				# Verify module actually loaded
				if lsmod | grep -q "^g_ether"; then
					module_loaded=1
					break
				fi
			fi
			sleep 2
			counter=$((counter + 1))
		done
		
		# If module still not loaded after retries, log error
		if [ $module_loaded -eq 0 ]; then
			logger -t usbc-gadget "ERROR: Failed to load g_ether module after $counter attempts"
			return 1
		fi
	fi

	# Wait for usb0 interface to appear (up to 15 seconds)
	# USB gadget interface may take time to initialize
	counter=0
	while [ $counter -lt 15 ]; do
		if ip link show {{ usbc_gadget_interface }} >/dev/null 2>&1; then
			break
		fi
		sleep 1
		counter=$((counter + 1))
	done

	# If usb0 interface appeared, add it to the mesh bridge
	if ip link show {{ usbc_gadget_interface }} >/dev/null 2>&1; then
		# Verify bridge exists before trying to add interface
		if ! ip link show {{ usbc_gadget_mesh_bridge }} >/dev/null 2>&1; then
			logger -t usbc-gadget "ERROR: Bridge {{ usbc_gadget_mesh_bridge }} does not exist"
			return 1
		fi
		
		# Bring up the interface first
		ip link set {{ usbc_gadget_interface }} up
		
		# Small delay to ensure interface is ready
		sleep 1
		
		# Add usb0 to the mesh network bridge using brctl
		# This ensures it's added immediately, then netifd will manage it
		if ! brctl addif {{ usbc_gadget_mesh_bridge }} {{ usbc_gadget_interface }} 2>&1; then
			# If brctl fails, try using bridge command (newer systems)
			if ! bridge link set dev {{ usbc_gadget_interface }} master {{ usbc_gadget_mesh_bridge }} 2>&1; then
				logger -t usbc-gadget "ERROR: Failed to add {{ usbc_gadget_interface }} to bridge {{ usbc_gadget_mesh_bridge }}"
				return 1
			fi
		fi
		
		logger -t usbc-gadget "Successfully added {{ usbc_gadget_interface }} to bridge {{ usbc_gadget_mesh_bridge }}"
		
		# Reload network to apply UCI bridge configuration and ensure persistence
		ubus call network reload
		
		# Small delay for network reload to complete
		sleep 2
	else
		logger -t usbc-gadget "ERROR: Interface {{ usbc_gadget_interface }} did not appear after module load"
		return 1
	fi
}

stop_service() {
	# Remove usb0 from bridge before bringing it down
	brctl delif {{ usbc_gadget_mesh_bridge }} {{ usbc_gadget_interface }} 2>/dev/null || true
	ip link set {{ usbc_gadget_interface }} down 2>/dev/null || true
}

reload_service() {
	start_service
}
