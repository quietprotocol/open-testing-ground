---
# Docker overlay2 storage configuration role

- name: Copy dockerd-overlay2.sh script to device
  ansible.builtin.copy:
    src: dockerd-overlay2.sh
    dest: /usr/bin/dockerd-overlay2.sh
    mode: '0755'
    owner: root
    group: root
  tags:
    - docker

- name: Ensure target directories exist
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ docker_data_root }}"
    - /mnt/docker-ext4
  tags:
    - docker

- name: Check if USB device exists
  ansible.builtin.stat:
    path: "{{ docker_usb_device }}"
  register: usb_device_stat
  tags:
    - docker

- name: Check if Docker ext4 image exists
  ansible.builtin.command:
    cmd: test -f {{ docker_image_path }}
  register: docker_image_stat
  when: not usb_device_stat.stat.exists
  changed_when: false
  failed_when: false
  tags:
    - docker

- name: Create Docker ext4 image (when USB not available)
  ansible.builtin.shell: |
    dd if=/dev/zero of={{ docker_image_path }} bs=1M count=0 seek=$(({{ docker_image_size_gb }}*1024))
    mkfs.ext4 -F -E lazy_itable_init=0,lazy_journal_init=0 {{ docker_image_path }}
  when: 
    - not usb_device_stat.stat.exists
    - docker_image_stat.rc != 0
  changed_when: true
  tags:
    - docker

- name: Configure bridge netfilter sysctl setting
  ansible.builtin.sysctl:
    name: net.bridge.bridge-nf-call-iptables
    value: '0'
    state: present
    sysctl_set: yes
    ignoreerrors: yes
  tags:
    - docker

- name: Configure Docker daemon via UCI
  ansible.builtin.shell: |
    uci set dockerd.globals=globals
    uci set dockerd.globals.storage_driver="{{ docker_storage_driver }}"
    uci set dockerd.globals.data_root="{{ docker_data_root }}/"
    uci set dockerd.globals.log_level="debug"
    uci set dockerd.globals.iptables="0"
    uci set dockerd.globals.ip6tables="0"
    uci delete dockerd.globals.alt_config_file 2>/dev/null || true
    uci commit dockerd
  tags:
    - docker

- name: Update /etc/rc.local to call dockerd-overlay2.sh
  ansible.builtin.blockinfile:
    path: /etc/rc.local
    marker: "# {mark} ANSIBLE MANAGED BLOCK - Docker storage setup"
    block: |
      # Docker storage setup
      /usr/bin/dockerd-overlay2.sh
    insertbefore: "^exit 0"
    create: yes
  tags:
    - docker

- name: Stop Docker service
  ansible.builtin.service:
    name: dockerd
    state: stopped
  ignore_errors: true
  tags:
    - docker

- name: Apply Docker overlay2 configuration immediately
  ansible.builtin.command:
    cmd: /usr/bin/dockerd-overlay2.sh
  register: docker_setup_result
  tags:
    - docker

- name: Start Docker service
  ansible.builtin.service:
    name: dockerd
    state: started
  ignore_errors: true
  tags:
    - docker

- name: Wait for Docker to be ready
  ansible.builtin.pause:
    seconds: 5
  tags:
    - docker

- name: Verify Docker storage driver
  ansible.builtin.shell: docker info | grep "Storage Driver"
  register: docker_storage_info
  changed_when: false
  failed_when: false
  tags:
    - docker

- name: Check if overlay2 storage driver is active
  ansible.builtin.set_fact:
    docker_storage_is_overlay2: "{{ docker_storage_info.stdout is search('overlay2') }}"
  tags:
    - docker

- name: Display Docker storage driver status
  ansible.builtin.debug:
    msg: |
      Docker Storage Driver: {{ docker_storage_info.stdout }}
      Overlay2 Active: {{ 'YES ✓' if docker_storage_is_overlay2 else 'NO ✗' }}
      {% if not docker_storage_is_overlay2 %}
      WARNING: Expected overlay2 storage driver but got something else!
      {% endif %}
  tags:
    - docker

- name: Fail if overlay2 is not active
  ansible.builtin.fail:
    msg: "Docker storage driver is not overlay2. Current driver: {{ docker_storage_info.stdout }}"
  when: not docker_storage_is_overlay2
  tags:
    - docker

- name: Detect system architecture for docker-buildx
  ansible.builtin.shell: |
    arch=$(uname -m)
    # Map to buildx architecture names
    if echo "$arch" | grep -qi "aarch64"; then
      echo "linux-arm64"
    elif echo "$arch" | grep -qi "armv7\|armhf"; then
      echo "linux-arm-v7"
    elif echo "$arch" | grep -qi "x86_64\|amd64"; then
      echo "linux-amd64"
    elif echo "$arch" | grep -qi "arm"; then
      echo "linux-arm-v7"
    else
      echo "linux-arm64"
    fi
  register: buildx_arch
  changed_when: false
  tags:
    - docker

- name: Ensure Docker CLI plugins directory exists
  ansible.builtin.file:
    path: /usr/lib/docker/cli-plugins
    state: directory
    mode: '0755'
  tags:
    - docker

- name: Check if docker-buildx already exists
  ansible.builtin.stat:
    path: /usr/lib/docker/cli-plugins/docker-buildx
  register: buildx_exists
  tags:
    - docker

- name: Download and install docker-buildx
  ansible.builtin.shell: |
    # Use version compatible with docker-compose 2.39.1 (v0.25.0)
    BUILDX_VERSION="v0.25.0"
    # Download buildx binary
    if command -v wget >/dev/null 2>&1; then
      wget -q "https://github.com/docker/buildx/releases/download/${BUILDX_VERSION}/buildx-${BUILDX_VERSION}.{{ buildx_arch.stdout }}" -O /usr/lib/docker/cli-plugins/docker-buildx || exit 1
    elif command -v curl >/dev/null 2>&1; then
      curl -sLf "https://github.com/docker/buildx/releases/download/${BUILDX_VERSION}/buildx-${BUILDX_VERSION}.{{ buildx_arch.stdout }}" -o /usr/lib/docker/cli-plugins/docker-buildx || exit 1
    else
      echo "ERROR: Neither wget nor curl available" >&2
      exit 1
    fi
    # Verify download succeeded
    if [ ! -f /usr/lib/docker/cli-plugins/docker-buildx ] || [ ! -s /usr/lib/docker/cli-plugins/docker-buildx ]; then
      echo "ERROR: Download failed or file is empty" >&2
      exit 1
    fi
    chmod +x /usr/lib/docker/cli-plugins/docker-buildx
  when: not buildx_exists.stat.exists
  tags:
    - docker

- name: Verify docker-buildx installation
  ansible.builtin.command:
    cmd: docker buildx version
  register: buildx_version
  changed_when: false
  failed_when: false
  tags:
    - docker

- name: Display docker-buildx status
  ansible.builtin.debug:
    msg: "docker-buildx: {{ buildx_version.stdout if buildx_version.rc == 0 else 'FAILED - check installation' }}"
  tags:
    - docker

# ========================================
# OpenWrt Firewall Configuration for Docker
# ========================================
# Docker containers need firewall rules to access the internet.
# The cloudtak network uses a fixed bridge name 'br-cloudtak'.
#
# SURGICAL APPROACH: Instead of creating a separate docker zone,
# we simply add the br-cloudtak bridge to the existing 'lan' zone.
# The lan zone already has masquerade and ACCEPT rules, so docker
# containers get internet access automatically.

- name: Add Docker bridge to LAN firewall zone
  ansible.builtin.shell: |
    # Check if br-cloudtak is already in the lan zone
    existing=$(uci show firewall 2>/dev/null | grep "@zone\[0\].*device.*br-cloudtak" || true)
    if [ -z "$existing" ]; then
      # Add br-cloudtak to the lan zone (zone[0] is always lan in OpenWrt)
      uci add_list firewall.@zone[0].device='br-cloudtak'
      uci commit firewall
      echo "added"
    else
      echo "exists"
    fi
  register: docker_firewall
  changed_when: docker_firewall.stdout == "added"
  tags:
    - docker
    - docker-firewall

- name: Reload firewall to apply Docker rules
  ansible.builtin.shell: |
    /etc/init.d/firewall reload
  when: docker_firewall.changed
  tags:
    - docker
    - docker-firewall

- name: Verify Docker firewall configuration
  ansible.builtin.shell: |
    echo "=== LAN Zone (includes Docker bridge) ==="
    uci show firewall.@zone[0] 2>/dev/null
    echo ""
    echo "=== nftables forward chain ==="
    nft list chain inet fw4 forward 2>/dev/null | grep -E 'lan|cloudtak' | head -5
  register: docker_firewall_status
  changed_when: false
  tags:
    - docker
    - docker-firewall

- name: Display Docker firewall configuration
  ansible.builtin.debug:
    msg: "{{ docker_firewall_status.stdout_lines }}"
  tags:
    - docker
    - docker-firewall
